<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Tutorials</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="overview.html">Overview</a></li><li><a href="rust-plugins.html"><strong aria-hidden="true">1.</strong> Rust Plugins</a></li><li class="affix"><a href="appendix-a.html">Appendix A: Rust Library Types</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Rust Tutorials</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#rust-tutorials" id="rust-tutorials"><h1>Rust Tutorials</h1></a>
<p>These are some miscellaneous <a href="http://rust-lang.org/">Rust</a> tutorials put together as I learn them. Hopefully they can help other people who might want to do the same things.</p>
<p>All of the sources for the projects are on GitHub: <a href="https://github.com/zicklag/rust-tutorials">zicklag/rust-tutorials</a>.</p>
<ul>
<li><a href="./rust-plugins.html">Rust Plugins</a> - Learn how to setup dynamically loadable plugins for your Rust app. <strong>Deprecated</strong></li>
</ul>
<a class="header" href="#rust-plugins" id="rust-plugins"><h1>Rust Plugins</h1></a>
<p>This is a guide for setting your Rust application up with Rust plugins that can be loaded dynamically at runtime. Additionally, this plugin setup allows plugins to make calls to the application's public API so that it can make use of the same data structures and utilities for extending the application.</p>
<blockquote>
<p><strong>Warning:</strong> After furthur testing, I cannot confirm that this plugin setup will work for all applications that have other crates as dependencies. It seems to work fine with the steps outlined in this tutorial, but I was not able to get it to work with a large project like <a href="https://github.com/amethyst/amethyst">Amethyst</a>.</p>
<p>Additionally, this will only allow you to create plugins using the same version of Rust that the application was built with. Unfortunately, these issues defeated my use-case, but the tutorial may still be useful for one reason or another so I leave it here for reference.</p>
</blockquote>
<p>This is a quick, somewhat unpolished tutorial that I figured I would make as I explored the subject for the first time myself.</p>
<p>The specific purpose for the plugins, in my case, is to allow for a Rust game to be extended/modded by writing Rust. I want the plugins to have full access to the game's API so that plugins are just about as powerful as making changes to the game core, without you having to manually create bindings to get access to engine internals.</p>
<p>The full source code for the final version of this tutorial can be found <a href="https://github.com/zicklag/rust-plugin-tutorial/tree/master/rust-plugins">here</a>.</p>
<blockquote>
<p><strong>Note:</strong> This guide assumes that you are on Linux, and has not been tested on Windows, or Mac, but, conceptually, everything should work the same except for the extensions for shared libraries being different on the different platforms ( .so on Linux, .dll on Windows, .dylib on Mac ).</p>
</blockquote>
<a class="header" href="#create-the-app" id="create-the-app"><h2>Create The App</h2></a>
<p>The first thing we need is a place to put our crates, like a <code>rust-plugins</code> folder. It is here that we will put our app crate and our plugin crate.</p>
<p>Now lets create the app directory inside the one we created for our project:</p>
<pre><code class="language-bash">cargo new --bin app
</code></pre>
<p>Now move to the new <code>app</code> directory edit the <code>src/main.rs</code> file to look like so:</p>
<pre><pre class="playpen"><code class="language-rust">use app;

fn main() {
    app::run();
}
</code></pre></pre>
<p>This will simply execute our app's run method. We want to keep the main function very simple. All of the application functionality will be put into the app's library. In that light, we need to create our crate's <code>src/lib.rs</code> file:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn run() {
    println!(&quot;Starting App&quot;);
}
#}</code></pre></pre>
<p>If you run <code>cargo run</code> now to run your app, you should get &quot;Starting App&quot; printed to the terminal. Now lets spend a little bit of time to understand what has happened. You've probably done this before, but in order to understand how plugins will work, we have to understand more about how different libraries and portions of our app end up a runnable program.</p>
<p>If we look in our <code>target/debug</code> directory, we can see the artifacts that were built when we ran <code>cargo run</code>.</p>
<pre><code class="language-bash">&gt; ls target/debug/
app  app.d  build/  deps/  examples/  incremental/  libapp.d  libapp.rlib  native/
</code></pre>
<p>In there we can see our program, <code>app</code>, which can be run manually:</p>
<pre><code class="language-bash">&gt; ./target/debug/app
Starting App
</code></pre>
<p>Rust has packed everything that your app needs to run inside of that one executable. If you copy that binary to any other system, it will run without needing any other libraries. Also the size of the binary is 1.7M.</p>
<p>The way that rust builds applications by default is great for most situations, and it lets you easily distribute your app just by providing a single binary, but for our use, we want to allow dynamically loading portions of the app that may not have come with it, and this requires some changes.</p>
<p>By default Rust will link all application dependencies <strong>statically</strong> into the the final executable. In this case, our app only depends on the standard library, which it uses to print to standard out. The problem with static linking is that only the app that is link to a static library can actually use the library. This means that if we have plugins, our plugins will not be able to call any of the functions in our application's library. For this tutorial we <em>do</em> want our plugins to be able to call our application's API to make use of utilities and functionality provided in our app. This requires <strong>dynamic linking</strong>.</p>
<p>To make rust create a dynamic library for our app that our plugins can link to, we first need to tell Cargo to compile the app as a dynamic library by adding this to the <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[lib]
crate-type = [&quot;dylib&quot;, &quot;rlib&quot;]
</code></pre>
<p>In the above config we tell cargo to compile a <code>dylib</code> or dynamic library <em>and</em> an <code>rlib</code> or rust library. The <code>dylib</code> will be a <code>.so</code> shared library that will contain the machine code for our app's library and is needed when running the app and plugins. The <code>rlib</code> will make a <code>.rlib</code> file that provides rust with extra metadata that allows it to link plugins to the app's library at compile time. Without the <code>rlib</code> build of the library, our plugins would not be able to tell which functions are defined in the library without us providing the entire source-code for the app. The <code>rlib</code> is almost like a kind of header file that gives rust the info it needs to link to the crate without needing source code ( I think ).</p>
<blockquote>
<p><strong>Note:</strong> There is another crate type called <code>cdylib</code> that can be used instead of <code>dylib</code>, but it behaves somewhat differently. It may be a better solution as it is not dependent on the Rust compiler version being exactly the same for the app and the plugins. I am trying to understand the full differences and have opened up a <a href="https://users.rust-lang.org/t/what-is-the-difference-between-dylib-and-cdylib/28847?u=zicklag">forum topic</a> on the Rust user forum to discuss it. My current understanding can be found in <a href="./appendix-a.html">Appendix A</a>.</p>
</blockquote>
<p>Additionally we need to tell cargo to add some flags to the its rust compiler calls. These settings go in a <code>.cargo/config</code> file:</p>
<pre><code class="language-toml">[build]
rustflags = [&quot;-C&quot;, &quot;prefer-dynamic&quot;, &quot;-C&quot;, &quot;rpath&quot;]
</code></pre>
<p><code>prefer-dynamic</code> tells the compiler to prefer dynamic linking when compiling the app. This means that instead of statically linking the standard library into the our app, it will leave the standard library as a separate dynamically linked shared library ( <code>.so</code> ) file. This means that both our app and our plugins will be able to link to the same standard library, without duplicating the standard library for each plugin.</p>
<p><code>rpath</code> tells the compiler to make the binary for our app look in the directory that it is in for shared libraries. This means that we can put the shared libraries that our app needs, such as the rust standard library, in the same director as the app binary and not require that the user add the libraries to the system PATH or the LD_LIBRARY_PATH.</p>
<p>If we run <code>cargo run</code> now, our app should still run the same, but things are a bit different under the hood.</p>
<p>For one, if we look in the <code>target/debug</code> directory now, we should see a <code>libapp.so</code> file in it which is about 14 kilobytes. Also, instead of our <code>app</code> binary being almost 2 megabytes, it is only 19 kilobytes. So, what happened? Well, instead of bundling everything up into our one binary, Rust has now compiled each library to its own dynamic library file ( the <code>.so</code> file, or <code>.dll</code> on Windows ) and dynamically linked our <code>app</code> binary to those libraries.</p>
<p>Dynamic linking means that, when you run the program, it will look around on your system for the libraries that it needs, because the libraries are not built into it. The places that the system will look for the dynamic libraries depends on the system. On Linux it will look in places like <code>/usr/lib</code> and also in any places indicated by the <code>LD_LIBRARY_PATH</code>. On Windows it will look in your <code>PATH</code>.</p>
<p>If you try to run the app manually, now you will actually get an error:</p>
<pre><code class="language-bash">&gt; ./target/debug/app
./target/debug/app: error while loading shared libraries: libstd-8e7d7d74c91e7cfe.so: cannot open shared object file: No such file or directory
</code></pre>
<p>This is because we have not put the Rust standard library somewhere that our app can find it! Because we added the <code>rpath</code> rust flag in our cargo config earlier, our app will look in the directory that it is in for dynamic libraries, as well as in the system search paths. The rust <code>libstd-*.so</code> file isn't in a system directory or in the executable's directory, so it throws an error saying that it cannot be found. All we have to do is copy that library to the our <code>target/debug</code> folder to get the app to run. If you are using rustup, you can find the libstd library in your rustup dir ( I'm using nightly rust, but make sure you choose whatever toolchain you compiled the app with ):</p>
<pre><code class="language-bash">&gt; cp ~/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/libstd-8e7d7d74c91e7cfe.so target/debug/
&gt; ./target/debug/app
Starting App
</code></pre>
<p>Now that our app can find the libraries it needs, it runs successfully! Also, the <code>libstd</code> file explains where the rest of the file size went when we switched to dynamic linking. The <code>libstd</code> library is 5M, which is larger than our executable was when it was statically linked, but that is probably because, when statically linking, rust can remove portions of the library that is not used, but when dynamically linking, you never know what portions of the library an app might use, so you have to make sure that it is all there all of the time.</p>
<p>Dynamic linking can be less convenient for distribution because you need more files with your app but it allows multiple applications to share the same libraries, which can save on disc space if there are many binaries or plugins that are using the same library. This helps us for our plugins use-case because all of the plugins will share the same app library and standard library.</p>
<a class="header" href="#create-an-app-library-function" id="create-an-app-library-function"><h3>Create an App Library Function</h3></a>
<p>Before we move on to creating our plugin, lets create a function that our plugin can call and put it in our app library:</p>
<p><strong>src/lib.rs:</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn test_app_func(message: &amp;str) {
    println!(&quot;test_app_func(\&quot;{}\&quot;)&quot;, message);
}
#}</code></pre></pre>
<p>Testing that our plugin can call this function in our app's library will prove that our plugin can, in fact, make use of our app's public rust API.</p>
<a class="header" href="#create-a-plugin" id="create-a-plugin"><h2>Create a Plugin</h2></a>
<p>The next thing we are going to do is create our plugin crate. Go ahead and cd back to your project folder and create the plugin crate alongside the app crate and the move to the plugin dir.</p>
<pre><code class="language-bash">cargo new --lib plugin1
cd plugin1
</code></pre>
<p>For this crate we are going to make similar <code>Cargo.toml</code> and <code>.config/cargo</code> changes that we make for our app to make it dynamically link all of its dependencies. The only difference in this case is that we don't need need to set the <code>crate-type</code> to include <code>rlib</code> in the <code>Cargo.toml</code> file. Instead we set it to <code>dylib</code> only:</p>
<p><strong>Cargo.toml:</strong></p>
<pre><code class="language-toml">[lib]
crate-type = [&quot;dylib&quot;]
</code></pre>
<p><strong>.cargo/config:</strong></p>
<pre><code class="language-toml">[build]
rustflags = [&quot;-C&quot;, &quot;prefer-dynamic&quot;, &quot;-C&quot;, &quot;rpath&quot;]
</code></pre>
<p>The reason the <code>rlib</code> build is not needed for plugins is because we don't plan on linking any other rust libraries to the plugin crate. The rlib build is only used when linking other rust libraries/binaries to this one. Granted, if you wanted to let your plugin have plugins, you would still want to build the <code>rlib</code>, but we're not going to take this that far here.</p>
<p>After that, we will add a <code>run()</code> function that will be called by our app to execute the plugin's functionality. Eventually plugins will be able to do more than just <code>run</code> but for now that is all we will do with it.</p>
<p><strong>src/lib.rs:</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate app;

#[no_mangle]
pub fn run() {
    println!(&quot;Running plugin1&quot;);
    app::test_app_func(&quot;Hello from plugin 1&quot;);
}
#}</code></pre></pre>
<p>Notice that we specify <code>app</code> as an external crate; if we had added <code>app</code> as a Cargo dependency, we could have done <code>use app;</code> instead. Our run function is simple and just prints some output before calling the <code>test_app_func</code> that we created in our app library. The <code>#[no_mangle]</code> attribute on the <code>run()</code> function tells the compiler not to add any extra metadata to that symbol in the compiled output, this allows us to call the function by name when we later load it into our app dynamically.</p>
<p>Attempting to <code>cargo build</code> the crate right now will tell us that it can't find the <code>app</code> crate. This is because we didn't add it as a dependency to our <code>Cargo.toml</code> file. Now, if we added the <code>app</code> crate to the plugin's dependencies, it would be able to compile, but it would also re-compile the app library, when we already have the app compiled. There is no reason to compile the app library twice, especially if it is a big app, so, instead, lets add the app library to our plugin's search path so that it will find our already built <code>app</code> crate.</p>
<p>To tell cargo how to find our app crate, we create a <code>build.rs</code> script. The <code>build.rs</code> script can be used to do any kind of setup necessary to compile a library. In our case we just need to feed cargo some specially understood flags that tell it where to find our pre-compiled <code>app</code> library.</p>
<p><strong>build.rs:</strong></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // Add our app's build directory to the lib search path.
    println!(&quot;cargo:rustc-link-search=../app/target/debug&quot;);
    // Add the app's dependency directory to the lib search path.
    // This is may be required if the app depends on any external &quot;derive&quot;
    // crates like the `dlopen_derive` crate that we add later.
    println!(&quot;cargo:rustc-link-search=../app/target/debug/deps&quot;);
    // Link to the `app` crate library. This tells cargo to actually link
    // to the `app` crate that we include using `extern crate app;`.
    println!(&quot;cargo:rustc-link-lib=app&quot;);
}
</code></pre></pre>
<p>Now we can run <code>cargo build</code> and we will get a new <code>libplugin1.so</code> file in our <code>target/debug</code> ( if it fails see note below ). As we intended, the plugin only contains the code that is in the plugin and weighs only 14 kilobytes. Yay, we have successfully built a plugin! Lets go over what happened when we built it.</p>
<blockquote>
<p><strong>note:</strong> If you run cargo build and get an error like <code>error[E0464]: multiple matching crates for 'app'</code>, change directory to your app directory and run <code>cargo clean</code> followed by <code>cargo build</code>. This will get rid of any extra <code>rlib</code> file that may have been left over from when we first built our app as a standalone binary. After doing that you should be able to come back to your plugin and successfully run <code>cargo build</code> to build the library.</p>
</blockquote>
<p>When we run <code>cargo build</code>, cargo will first run our <code>build.rs</code> script and read the standard output of that script to look for cargo directives. In this case, our script tells cargo to look in the debug build dir of our app for libraries and to link to the <code>app</code> library. When compiling our rust library, the compiler will read our app's <code>libapp.rlib</code> which contains all of the metadata needed to compile rust code that talks to that library, similar to C/C++ header files. After the rust code is compiled, it will call the system linker to link our plugin library, <code>libplugin1.so</code>, to <code>libapp.so</code> so that it can call functions defined in our app library.</p>
<p>Now that we have an app and a plugin, we need to make our app load the plugin!</p>
<a class="header" href="#loading-a-plugin" id="loading-a-plugin"><h2>Loading a Plugin</h2></a>
<p>Now we are ready to actually do some awesome stuff, loading the plugin into our app. To load the plugin we are going to use the <a href="https://crates.io/crates/dlopen"><code>dlopen</code></a> crate. The <code>dlopen</code> crate will do the actual loading of the shared libraries and takes care of the lower level stuff so we don't have to. Our first step, then, is to add that crate to the <code>Cargo.toml</code> for our app.</p>
<pre><code class="language-toml">[dependencies]
dlopen = &quot;0.1.6&quot;
dlopen_derive = &quot;0.1.3&quot;
</code></pre>
<p>Then update your app's <code>src/lib.rs</code> file to look like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use]
extern crate dlopen_derive;
use dlopen::wrapper::{Container, WrapperApi};

#[derive(WrapperApi)]
struct PluginApi {
    run: extern fn(),
}

pub fn run() {
    println!(&quot;Starting App&quot;);

    let plugin_api_wrapper: Container&lt;PluginApi&gt; = unsafe { Container::load(&quot;plugins/libplugin1.so&quot;) }.unwrap();
    plugin_api_wrapper.run();
}

pub fn test_app_func(message: &amp;str) {
    println!(&quot;test_app_func(\&quot;{}\&quot;)&quot;, message);
}
#}</code></pre></pre>
<p>There is a little bit going on here, but it is still fairly simple, thanks to the <code>dlopen</code> library. We create a <code>PluginApi</code> struct that represents the functions that we can call in loaded plugins. We use <code>dlopen</code> to load our plugin shared library, and store it in <code>plugin_api_wrapper</code>. We can then call the <code>run()</code> function, and it will execute the <code>run()</code> function in our plugin. The <code>run()</code> function in our plugin should then call <code>test_app_func</code> with a message that should be printed to the console.</p>
<p>Before we run it, lets create a <code>plugins</code> directory in our app crate directory and copy our <code>libplugin1.so</code> file into it from our plugin's build directory. After that, go ahead and test it with <code>cargo run</code>:</p>
<pre><code class="language-bash">&gt; cd app
&gt; mkdir plugins
&gt; cp ../plugin1/target/debug/libplugin1.so plugins
&gt; cargo run
   Compiling app v0.1.0 (/home/zicklag/rust/test-lab/plugins/rust-plugins-test2/project-tutorial/app)
   ...
    Finished dev [unoptimized + debuginfo] target(s) in 1.67s
     Running `target/debug/app`
Starting App
Running plugin1
test_app_func(&quot;Hello from plugin 1&quot;)
</code></pre>
<p>It works! You should also be able to run it manually, but you will have to re-copy the libstd library back into the build directory because we ran a <code>cargo clean</code> earlier:</p>
<pre><code class="language-bash">&gt; cp ~/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/libstd-8e7d7d74c91e7cfe.so target/debug/
&gt; ./target/debug/app
Starting App
Running plugin1
test_app_func(&quot;Hello from plugin 1&quot;)
</code></pre>
<p>Notice that Rust bundled the new dependencies of our app, such as the <code>dlopen</code> crate, into our <code>libapp.so</code>; it is now 534 kilobytes instead of the original 14 kilobytes. Apparently, even though it dynamically links <code>libstd</code>, it decided to statically link the <code>dlopen</code> crate to <code>libapp</code>. This is fine and is nice because we don't need to have a shared library for <em>every</em> crate dependency. If we wanted to expose one of the crates that our app depends on to our plugins, we could do that simply by re-exporting the library in our app library ( this is yet to be tested ).</p>
<a class="header" href="#notes-so-far" id="notes-so-far"><h2>Notes So Far</h2></a>
<p>In this example, we added the path to our app library to our plugin's build script so that we could compile the plugin with a link to our app. In a more organized situation, as the designer of the app, you would probably provide the shared libraries and the rlibs that are required to link to the app for your users, so that they could build their plugins against those, without having to have the source code and compile the app themselves.</p>
<p>What we are going to focus on next is making our plugin API more powerful so that the app has a way to find out more about the plugin, instead of just having a <code>run</code> function.</p>
<a class="header" href="#improving-the-plugin-api--and-our-app-" id="improving-the-plugin-api--and-our-app-"><h2>Improving the Plugin API ( And Our App )</h2></a>
<p>Now that we have basics of plugin loading, lets make our app do something. We're going to setup a simple app that will infinitely prompt for a command, and respond to the user's input. The only command that comes with the app will be the <code>exit</code> command that lets the user exit the program. Otherwise, all other commands will be provided by plugins.</p>
<p>Let's get that loop going without plugins first:</p>
<p><strong>src/lib.rs:</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// ...
pub fn run() {
    println!(&quot;Starting App&quot;);

    // Comment this out for now
    // let plugin_api_wrapper: Container&lt;PluginApi&gt; = unsafe { Container::load(&quot;plugins/libplugin1.so&quot;) }.unwrap();
    // plugin_api_wrapper.run();

    loop {
        // Prompt
        println!(&quot;Enter command:&quot;);

        // Read input
        let mut message = String::new();
        std::io::stdin().read_line(&amp;mut message).unwrap();

        // Trim newline
        message = message.trim().into();

        // Check command
        if message == &quot;exit&quot; {
            break
        }
    }
}
// ...
#}</code></pre></pre>
<p>Now we can <code>cargo run</code> our app and get our own little command prompt.</p>
<p>Now we want to refine our plugin API a bit. Instead of using a <code>run</code> function to execute our plugins, we are going to use an <code>get_plugin</code> function which is expected to return a pointer to a struct that implements a <code>Plugin</code> trait. The <code>Plugin</code> trait will require that each plugin implement the <code>handle_command()</code> function so that it can handle commands pass to the user.</p>
<p>Here is the full updated <code>app/src/lib.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use]
extern crate dlopen_derive;
use dlopen::wrapper::{Container, WrapperApi};

// The trait that must be implemented by plugins to allow them to handle
// commands.
pub trait Plugin {
    fn handle_command(&amp;self, command: &amp;str);
}

#[derive(WrapperApi)]
struct PluginApi {
    // The plugin library must implement this function and return a raw pointer
    // to a Plugin struct.
    get_plugin: extern fn() -&gt; *mut Plugin,
}

pub fn run() {
    println!(&quot;Starting App&quot;);

    // Load the plugin by name from the plugins directory
    let plugin_api_wrapper: Container&lt;PluginApi&gt; = unsafe { Container::load(&quot;plugins/libplugin1.so&quot;) }.unwrap();
    let plugin = unsafe { Box::from_raw(plugin_api_wrapper.get_plugin()) };

    loop {
        // Prompt
        println!(&quot;Enter command:&quot;);

        // Read input
        let mut message = String::new();
        std::io::stdin().read_line(&amp;mut message).unwrap();

        // Trim newline
        message = message.trim().into();

        // Give the plugin a chance to handle the command
        plugin.handle_command(&amp;message);

        // Check command
        if message == &quot;exit&quot; {
            break
        }
    }
}
#}</code></pre></pre>
<p>And our updated <code>plugin1/src/lib.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate app;

use app::Plugin;

// Our plugin implementation
struct Plugin1;

impl Plugin for Plugin1 {
    fn handle_command(&amp;self, command: &amp;str) {
        // Handle the `plugin1` command
        if command == &quot;plugin1&quot; {
            println!(&quot;Hey you triggered my 'plugin1' command!&quot;);

        // Handle an `echo` command
        } else if command.starts_with(&quot;echo &quot;) {
            println!(&quot;Echo-ing what you said: {}&quot;, command);
        }
    }
}

#[no_mangle]
pub fn get_plugin() -&gt; *mut Plugin {
    println!(&quot;Running plugin1&quot;);

    // Return a raw pointer to an instance of our plugin
    Box::into_raw(Box::new(Plugin1 {}))
}
#}</code></pre></pre>
<p>Now we can:</p>
<ul>
<li>rebuild our app</li>
<li>rebuild our plugin</li>
<li>copy the newly built <code>libplugin1.so</code> into our app's <code>plugins/</code> directory, and</li>
<li>run our app to get our mini command prompt</li>
</ul>
<p>Here is an example of the result:</p>
<pre><code class="language-txt">Starting App
Running plugin1
Enter command:
plugin1
Hey you triggered my 'plugin1' command!
Enter command:
echo hello world
Echo-ing what you said: echo hello world
Enter command:
exit
</code></pre>
<p>We used our plugin to provide custom commands to our command prompt!</p>
<p>This is as far as this tutorial will take you and there is obviously a lot that could be improved. For one, you probably don't want to be loading plugins by name and you are going to want to be able to have more than one. All of that is simple to implement on top of the base that we have worked on here and I leave it up to the reader to explore how to do that if they so desire.</p>
<a class="header" href="#closing-thoughts" id="closing-thoughts"><h2>Closing Thoughts</h2></a>
<p>This is actually the first time that I have done any of this, so I'm still getting to understand how everything fits together, but hopefully this presents a good picture of how you can setup plugins in Rust.</p>
<p>Many thanks to @Michael-F-Bryan for the plugin section of his <a href="https://michael-f-bryan.github.io/rust-ffi-guide/">Rust FFI Guide</a>. I wouldn't have figure out how to do this without that. I may have missed something or given incorrect instructions somewhere in the tutorial so open an issue if you have any problems with it. :smiley:</p>
<a class="header" href="#appendix-a-rust-library-types" id="appendix-a-rust-library-types"><h1>Appendix A: Rust Library Types</h1></a>
<a class="header" href="#library-types-evaluation" id="library-types-evaluation"><h2>Library Types Evaluation</h2></a>
<p>Here is my current understanding of different Rust library types.</p>
<a class="header" href="#rlib" id="rlib"><h3>Rlib</h3></a>
<p><code>rlib</code>'s are Rust static libraries. They contain all of the metadata and code necessary to build a Rust crate and link it into another Rust crate statically. Given just the <code>rlib</code> for a crate, you can include that crate into a Rust program by using <code>extern crate crate_name</code>. Even if you are dynamically linking a crate like a <code>.dll</code>, <code>.so</code>, etc., you will still need to have the <code>rlib</code> to include that crate into another crate because they shared library is missing some of the required metadata ( I think ).</p>
<a class="header" href="#cdylib" id="cdylib"><h3>Cdylib</h3></a>
<p><code>cdylib</code>'s are primarily designed for building shared libraries that can be linked into C/C++ programs.</p>
<ul>
<li>They have a minimum size of ~2.2M on Linux, so the smallest <code>cdylib</code> is larger than the smallest <code>dylib</code>. I don't have any idea why the minimum size is so large.</li>
<li>They are designed for building a C ABI that can be dynamically linked to C/C++ programs ( and Rust programs that define extern blocks )
<ul>
<li>If you want to expose any portion of the a <code>cdylib</code>'s interface over the C ABI you must use <strong>Extern Functions</strong>.</li>
<li>If you want to link a Rust program to a Rust <code>cdylib</code> over the C ABI you have to use <strong>Extern Blocks</strong> ( See Rust reference doc ).</li>
</ul>
</li>
<li>When building a <code>cdylib</code>, any functions that are <strong>not</strong> exposed through an extern block will be automatically stripped from the generated library as an optimization.
<ul>
<li>For example, if you build a <code>cdylib</code> for a large rust library and you do not export any functions using the extern keyword, the library will be essentially empty and will be about 2.2M ( because that is the minimum size for a <code>cdylib</code> ).</li>
</ul>
</li>
</ul>
<a class="header" href="#dylib" id="dylib"><h3>Dylib</h3></a>
<p><code>dylib</code>'s are Rust shared libraries which have an unstable ABI that can change across Rust releases.</p>
<ul>
<li>To build a <code>dylib</code>, you probably need the <code>-C prefer-dynamic</code> rustflag set so that it will not attempt to statically link the standard library.</li>
<li>Within the same Rust version, you can dynamically link to a Rust <code>dylib</code> from a Rust crate <strong>without</strong> having to use extern functions or blocks because it will go over the Rust ABI.</li>
<li><code>dylib</code>'s will <strong>not</strong> strip out any unused functions when built. Even if none of the functions in the library are explicitly expose or used in the crate, all of the functions will still be included in the generated library.</li>
</ul>
<a class="header" href="#proposal-for-creating-a-stable-rust-dynamic-linking-strategy" id="proposal-for-creating-a-stable-rust-dynamic-linking-strategy"><h2>Proposal for Creating a Stable Rust Dynamic Linking Strategy</h2></a>
<blockquote>
<p><strong>Note:</strong> This is just a draft for my thoughts about a way to make dynamic linking more stable and usable in Rust.</p>
</blockquote>
<p>The largest problem with dynamically linking Rust libraries, as far as I understand it, is that there is no stable ABI for Rust right now and, according to some, there may never be. Still, dynamic linking can be very useful, like in my use-case of creating a Rust plugin system, where plugins have access to the application's full Rust interface.</p>
<blockquote>
<p>My proposal is to provide a way to tell the Rust compiler to automatically expose all public Rust interfaces in a crate over the C ABI and also provide a way to import the external crate over the C ABI into another Rust crate.</p>
</blockquote>
<p>The problem with using <code>dylib</code> for creating Rust dynamic libraries is that you cannot link to them from Rust crates that are not built using the <strong>exact</strong> same version of the Rust compiler. The problem with using <code>cdylib</code> is that it only exposes the items that are explicitly exposed using the <code>extern</code> keyword. While this makes sense for building C/C++ interfaces, it does not make sense for trying to link a full Rust library to another rust library as that would require you to manually create extern functions and blocks for the entire Rust interface you want to link to.</p>
<p>If there was a way to build a Rust library with a C ABI and import it over that ABI, the library could be compatible with different rust versions without having to stabilize Rust's own ABI. I'm imagining that this would have something like the following changes:</p>
<ul>
<li>There is now a new <code>rcdylib</code> ( Rust C Dylib, probably a better name for that ) crate type that will cause Rust to build a shared library that exposes all of the Rust functions over the C ABI.</li>
<li>There is now a new way to import external crates: <code>extern &quot;C&quot; crate crate_name;</code> Including a crate into another crate like this will cause it to use the C ABI to call any functions on that imported crate.</li>
</ul>
<a class="header" href="#caveats" id="caveats"><h3>Caveats</h3></a>
<a class="header" href="#derive-macros" id="derive-macros"><h4>Derive Macros</h4></a>
<p>In order to facilitate dynamically linking to Rust libraries that provide derive macros, it might be required that derive plugins be compiled as <code>rcdylib</code>'s as well. Otherwise, if you are attempting to compile Rust crate A and dynamically link it to Rust crate B, and the version of Rust you are using to compile crate A is different than crate B, the rustc binary compiling crate A will not be able to successfully link to the derive macro shared libraries that were built using crate B's version of Rust.</p>
<a class="header" href="#disclaimer" id="disclaimer"><h3>Disclaimer</h3></a>
<p>I don't fully understand the way that Rust libraries are linked and I don't have any in-depth knowledge of the compiler. This proposal is made based on the best information that I could obtain right now. I would like to get feedback on whether or not what I'm saying makes any sense, and whether or not this could be feasible to work into Rust.</p>
<p>If there is another way to achieve what I am trying to achieve, then I would be happy to go with an alternative that doesn't require changing the Rust compiler.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
